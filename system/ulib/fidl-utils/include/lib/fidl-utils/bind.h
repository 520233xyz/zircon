// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#pragma once

#include <fbl/type_support.h>
#include <lib/async/dispatcher.h>
#include <lib/fidl/bind.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

namespace fidl {
namespace internal {

template <typename>
struct MemberFunctionTraits;

template <typename R, typename T, typename... Args>
struct MemberFunctionTraits<R (T::*)(Args...)> {
    typedef T instance_type;
};

} // namespace internal

// A wrapper class which helps binding operations to a channel, and which
// helps creating C-compatible member-binding functions.
//
// This class ensures that the "void*" context value passed to |fidl_bind|
// is the same value used to dispatch to member functions.
template <typename T>
struct Binder {
    // Bind a member of a base class to a FIDL dispatch function, to allow
    // compatibility with the C bindings.
    //
    // For a FIDL function:
    //
    //   1: MyFunction(Args) -> (ReturnValue);
    //
    // The following C signature will be generated by the FIDL compiler, and is expected in a
    // server's dispatch table that wishes to implement this interface:
    //
    //   zx_status_t MyFunction(void* ctx, Args... args, fidl_txn_t* txn);
    //
    // This functionality can be implemented with this helper like so:
    //
    //   class MyClass {
    //   public:
    //       zx_status_t FunctionImplementation(Args... args, fidl_txn_t* txn) { ... }
    //   };
    //
    //   fidl_MyInterface_ops_t ops = {
    //       .MyFunction = Binder<MyClass>::BindMember<&MyClass::FunctionImplementation>
    //   };
    //
    // Which will instantiate a function with a signature matching the auto-generated "MyFunction"
    // C binding, that automatically invokes the FunctionImplementation member function, using a
    // "MyClass" instance as context.
    template <auto Fn,
              typename U = typename internal::MemberFunctionTraits<decltype(Fn)>::instance_type,
              typename... Args>
    static zx_status_t BindMember(void* ctx, Args... args) {
        static_assert(fbl::is_convertible_pointer<T*, U*>::value,
                      "Binding to method of invalid class");
        auto instance = static_cast<T*>(ctx);
        return (instance->*Fn)(static_cast<decltype(args)&&>(args)...);
    }

    // A utility function which simplifies binding methods of derived methods to FIDL
    // dispatch functions.
    //
    // A typical use case would look like the following:
    //
    // FIDL:
    //
    //   1: MyFunction(Args) -> (ReturnValue);
    //
    // C++:
    //
    //   class MyClass {
    //   public:
    //       zx_status_t FunctionImplementation(Args... args, fidl_txn_t* txn) {
    //           ...;
    //       }
    //
    //       zx_status_t Bind(async_dispatcher_t* dispatcher, zx::channel channel) {
    //           static constexpr Interface_ops_t kOps = {
    //               .MyFunction = Binder<MyClass>::BindMember<&MyClass::FunctionImplementation>,
    //           };
    //           return Binder<MyClass>::BindOps<Dispatch>(dispatcher, channel, this, &kOps);
    //       }
    //   }
    //
    //   ...
    //
    //   MyClass instance;
    //   instance.Bind(dispatcher, channel);
    template <auto Dispatch, typename Ops>
    static zx_status_t BindOps(async_dispatcher_t* dispatcher, zx::channel channel,
                               T* ctx, const Ops* ops) {
        static_assert(fbl::is_same<decltype(Dispatch),
                                   zx_status_t (*)(void*, fidl_txn_t*, fidl_msg_t*, const Ops* ops)
                                  >::value, "Invalid dispatch function");
        return fidl_bind(dispatcher, channel.release(),
                         reinterpret_cast<fidl_dispatch_t*>(Dispatch), ctx, ops);
    }
};

} // namespace fidl
